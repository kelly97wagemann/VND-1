//
// Generated file, do not edit! Created by nedtool 5.4 from inet/networklayer/icmpv6/Ipv6NdMessage.msg.
//

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#ifndef __INET_IPV6NDMESSAGE_M_H
#define __INET_IPV6NDMESSAGE_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0504
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {

class Ipv6NdPrefixInformation;
struct InterfaceIdentifier;
class Ipv6NdVehicularPrefixInformation;
class Ipv6NdVehicularServiceInformation;
class Ipv6NdAddressRegistrationOption;
class Ipv6NdVehicularMobilityInformation;
class Mipv6NdAdvertisementInterval;
class Mipv6HaInformation;
class Ipv6NdMessage;
class Ipv6RouterSolicitation;
class Ipv6RouterAdvertisement;
class Ipv6NeighbourSolicitation;
class Ipv6NeighbourAdvertisement;
class Ipv6Redirect;
class Ipv6DuplicateAddrReq;
class Ipv6DuplicateAddrConfirm;
class Ipv6NdControlInfo;
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/linklayer/common/MacAddress_m.h" // import inet.linklayer.common.MacAddress

#include "inet/networklayer/icmpv6/Icmpv6Header_m.h" // import inet.networklayer.icmpv6.Icmpv6Header

#include "inet/networklayer/contract/ipv6/Ipv6Address_m.h" // import inet.networklayer.contract.ipv6.Ipv6Address


namespace inet {

// cplusplus {{
const B IPv6ND_LINK_LAYER_ADDRESS_OPTION_LENGTH = B(8);    // RFC 2461, Section 4.6.1. Source/Target Link-layer Address
const B IPv6ND_PREFIX_INFORMATION_OPTION_LENGTH = B(32);   // RFC 2461, Section 4.6.2. Prefix Information
const B IPv6ND_REDIRECTED_HEADER_OPTION_LENGTH = B(8);     // 8 + redirected packet, RFC 2461, Section 4.6.3. Redirected Header.
                                                           // The original packet truncated to ensure that the size of the redirect message does not exceed 1280 octets.
const B IPv6ND_MTU_OPTION_LENGTH = B(8);                   // RFC 2461, Section 4.6.4. MTU

//#include "inet/networklayer/common/InterfaceToken.h"
//using namespace inet;
#include "inet/common/INETDefs.h"
#include "inet/common/Compat.h"
// }}

/**
 * Enum generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:49</tt> by nedtool.
 * <pre>
 * // TLB options (type, length, bytes), length must be divisible by eight, max value is 8*255
 * // Type codes:
 * enum Ipv6NdOptionTypes
 * {
 *     IPv6ND_SOURCE_LINK_LAYER_ADDR_OPTION = 1;          // RFC 2461  SLLAO
 *     IPv6ND_TARGET_LINK_LAYER_ADDR_OPTION = 2;          // RFC 2461  TLLAO
 *     IPv6ND_ADDRESS_REGISTRATION_OPTION = 33;     // RFC 6775 ARO 
 * }
 * </pre>
 */
enum Ipv6NdOptionTypes {
    IPv6ND_SOURCE_LINK_LAYER_ADDR_OPTION = 1,
    IPv6ND_TARGET_LINK_LAYER_ADDR_OPTION = 2,
    IPv6ND_ADDRESS_REGISTRATION_OPTION = 33
};

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:60</tt> by nedtool.
 * <pre>
 * //
 * // IPv6ND Prefix Information
 * // RFC 2461 / RFC 4861 Section 4.6.2
 * // RFC 3775 Section 7.2 (routerAddressFlag)
 * //
 * class Ipv6NdPrefixInformation extends cObject
 * {
 *     unsigned short prefixLength;
 *     bool onlinkFlag;        //L-bit
 *     bool autoAddressConfFlag;    //A-bit
 *     bool routerAddressFlag;        //R-bit: used in case of MIPv6 when the H-bit is set
 *     unsigned int validLifetime;    // seconds
 *     unsigned int preferredLifetime;    // seconds
 *     Ipv6Address prefix;
 * 
 *     //    XIANG ZHONG
 *     unsigned int distance;  //8-bit, distance between the subnet annoucing this prefix and the subnet 
 * 							//corresponding to this prefix in terms of the number of hops 
 * 
 * }
 * 
 * //XIANG ZHONG
 * //************Multihop Duplicate Address Detection Staff********************************  /
 * //class InterfaceIdentifier
 * //{  
 * //    uint32 normal;
 * //    uint32 low;
 * //    short len;    // in bits, 1..64
 * //}
 * </pre>
 */
class INET_API Ipv6NdPrefixInformation : public ::omnetpp::cObject
{
  protected:
    unsigned short prefixLength = 0;
    bool onlinkFlag = false;
    bool autoAddressConfFlag = false;
    bool routerAddressFlag = false;
    unsigned int validLifetime = 0;
    unsigned int preferredLifetime = 0;
    Ipv6Address prefix;
    unsigned int distance = 0;

  private:
    void copy(const Ipv6NdPrefixInformation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NdPrefixInformation&);

  public:
    Ipv6NdPrefixInformation();
    Ipv6NdPrefixInformation(const Ipv6NdPrefixInformation& other);
    virtual ~Ipv6NdPrefixInformation();
    Ipv6NdPrefixInformation& operator=(const Ipv6NdPrefixInformation& other);
    virtual Ipv6NdPrefixInformation *dup() const override {return new Ipv6NdPrefixInformation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getPrefixLength() const;
    virtual void setPrefixLength(unsigned short prefixLength);
    virtual bool getOnlinkFlag() const;
    virtual void setOnlinkFlag(bool onlinkFlag);
    virtual bool getAutoAddressConfFlag() const;
    virtual void setAutoAddressConfFlag(bool autoAddressConfFlag);
    virtual bool getRouterAddressFlag() const;
    virtual void setRouterAddressFlag(bool routerAddressFlag);
    virtual unsigned int getValidLifetime() const;
    virtual void setValidLifetime(unsigned int validLifetime);
    virtual unsigned int getPreferredLifetime() const;
    virtual void setPreferredLifetime(unsigned int preferredLifetime);
    virtual const Ipv6Address& getPrefix() const;
    virtual Ipv6Address& getPrefixForUpdate() { return const_cast<Ipv6Address&>(const_cast<Ipv6NdPrefixInformation*>(this)->getPrefix());}
    virtual void setPrefix(const Ipv6Address& prefix);
    virtual unsigned int getDistance() const;
    virtual void setDistance(unsigned int distance);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NdPrefixInformation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NdPrefixInformation& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/networklayer/icmpv6/Ipv6NdMessage.msg:85 by nedtool.
 */
struct INET_API InterfaceIdentifier
{
    InterfaceIdentifier();
    uint32_t normal;
    uint32_t low;
    short len;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const InterfaceIdentifier& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, InterfaceIdentifier& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InterfaceIdentifier& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InterfaceIdentifier& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:92</tt> by nedtool.
 * <pre>
 * class Ipv6NdVehicularPrefixInformation extends cObject
 * {
 *     unsigned int type; //type- TBD
 *     unsigned int optionLength = 3;
 *     unsigned int prefixLength;
 *     unsigned int distance;  //8-bit, distance between the subnet annoucing this prefix and the subnet 
 * 							//corresponding to this prefix in terms of the number of hops 
 *     Ipv6Address prefix;
 * }
 * </pre>
 */
class INET_API Ipv6NdVehicularPrefixInformation : public ::omnetpp::cObject
{
  protected:
    unsigned int type = 0;
    unsigned int optionLength = 3;
    unsigned int prefixLength = 0;
    unsigned int distance = 0;
    Ipv6Address prefix;

  private:
    void copy(const Ipv6NdVehicularPrefixInformation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NdVehicularPrefixInformation&);

  public:
    Ipv6NdVehicularPrefixInformation();
    Ipv6NdVehicularPrefixInformation(const Ipv6NdVehicularPrefixInformation& other);
    virtual ~Ipv6NdVehicularPrefixInformation();
    Ipv6NdVehicularPrefixInformation& operator=(const Ipv6NdVehicularPrefixInformation& other);
    virtual Ipv6NdVehicularPrefixInformation *dup() const override {return new Ipv6NdVehicularPrefixInformation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getType() const;
    virtual void setType(unsigned int type);
    virtual unsigned int getOptionLength() const;
    virtual void setOptionLength(unsigned int optionLength);
    virtual unsigned int getPrefixLength() const;
    virtual void setPrefixLength(unsigned int prefixLength);
    virtual unsigned int getDistance() const;
    virtual void setDistance(unsigned int distance);
    virtual const Ipv6Address& getPrefix() const;
    virtual Ipv6Address& getPrefixForUpdate() { return const_cast<Ipv6Address&>(const_cast<Ipv6NdVehicularPrefixInformation*>(this)->getPrefix());}
    virtual void setPrefix(const Ipv6Address& prefix);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NdVehicularPrefixInformation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NdVehicularPrefixInformation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:102</tt> by nedtool.
 * <pre>
 * class Ipv6NdVehicularServiceInformation extends cObject
 * {
 *     unsigned int type; //type- TBD
 *     unsigned int portNumber = 1000;
 *     unsigned int optionLength = 3;  //length=3   
 *     unsigned int protocol; // upper layer protocol, e.g. TCP, UDP , SCTP 
 *     Ipv6Address serviceAddress;// node providing this vehicular service
 * 
 * }
 * </pre>
 */
class INET_API Ipv6NdVehicularServiceInformation : public ::omnetpp::cObject
{
  protected:
    unsigned int type = 0;
    unsigned int portNumber = 1000;
    unsigned int optionLength = 3;
    unsigned int protocol = 0;
    Ipv6Address serviceAddress;

  private:
    void copy(const Ipv6NdVehicularServiceInformation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NdVehicularServiceInformation&);

  public:
    Ipv6NdVehicularServiceInformation();
    Ipv6NdVehicularServiceInformation(const Ipv6NdVehicularServiceInformation& other);
    virtual ~Ipv6NdVehicularServiceInformation();
    Ipv6NdVehicularServiceInformation& operator=(const Ipv6NdVehicularServiceInformation& other);
    virtual Ipv6NdVehicularServiceInformation *dup() const override {return new Ipv6NdVehicularServiceInformation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getType() const;
    virtual void setType(unsigned int type);
    virtual unsigned int getPortNumber() const;
    virtual void setPortNumber(unsigned int portNumber);
    virtual unsigned int getOptionLength() const;
    virtual void setOptionLength(unsigned int optionLength);
    virtual unsigned int getProtocol() const;
    virtual void setProtocol(unsigned int protocol);
    virtual const Ipv6Address& getServiceAddress() const;
    virtual Ipv6Address& getServiceAddressForUpdate() { return const_cast<Ipv6Address&>(const_cast<Ipv6NdVehicularServiceInformation*>(this)->getServiceAddress());}
    virtual void setServiceAddress(const Ipv6Address& serviceAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NdVehicularServiceInformation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NdVehicularServiceInformation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:113</tt> by nedtool.
 * <pre>
 * class Ipv6NdAddressRegistrationOption extends cObject
 * {
 *     unsigned int type = IPv6ND_ADDRESS_REGISTRATION_OPTION; //type = 33
 *     unsigned int optionLength = 2;  //length=2   
 *     // 0-success  1-duplicate address 2-neighbor cache full 
 *     unsigned int status = 0;  // indicate the status of a registration in the NA response.Must be set to 0 in NS messages  
 *     unsigned int registLifeTime;  // registration lifetime 
 *     //EUI 64    EUI-64 interface identifier uniquely identify the interface of the registered address      
 *     InterfaceIdentifier EUI64;
 * 
 * }
 * </pre>
 */
class INET_API Ipv6NdAddressRegistrationOption : public ::omnetpp::cObject
{
  protected:
    unsigned int type = IPv6ND_ADDRESS_REGISTRATION_OPTION;
    unsigned int optionLength = 2;
    unsigned int status = 0;
    unsigned int registLifeTime = 0;
    InterfaceIdentifier EUI64;

  private:
    void copy(const Ipv6NdAddressRegistrationOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NdAddressRegistrationOption&);

  public:
    Ipv6NdAddressRegistrationOption();
    Ipv6NdAddressRegistrationOption(const Ipv6NdAddressRegistrationOption& other);
    virtual ~Ipv6NdAddressRegistrationOption();
    Ipv6NdAddressRegistrationOption& operator=(const Ipv6NdAddressRegistrationOption& other);
    virtual Ipv6NdAddressRegistrationOption *dup() const override {return new Ipv6NdAddressRegistrationOption(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getType() const;
    virtual void setType(unsigned int type);
    virtual unsigned int getOptionLength() const;
    virtual void setOptionLength(unsigned int optionLength);
    virtual unsigned int getStatus() const;
    virtual void setStatus(unsigned int status);
    virtual unsigned int getRegistLifeTime() const;
    virtual void setRegistLifeTime(unsigned int registLifeTime);
    virtual const InterfaceIdentifier& getEUI64() const;
    virtual InterfaceIdentifier& getEUI64ForUpdate() { return const_cast<InterfaceIdentifier&>(const_cast<Ipv6NdAddressRegistrationOption*>(this)->getEUI64());}
    virtual void setEUI64(const InterfaceIdentifier& EUI64);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NdAddressRegistrationOption& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NdAddressRegistrationOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:126</tt> by nedtool.
 * <pre>
 * //final task
 * class Ipv6NdVehicularMobilityInformation extends cObject
 * {
 *     unsigned short length;  //length
 *     unsigned int type; //type- TBD
 * 
 *     //mobility information    128 bit mobility information, such as position, speed and direction 
 * 
 * }
 * //************Multihop Duplicate Address Detection Staff********************************  /
 * </pre>
 */
class INET_API Ipv6NdVehicularMobilityInformation : public ::omnetpp::cObject
{
  protected:
    unsigned short length = 0;
    unsigned int type = 0;

  private:
    void copy(const Ipv6NdVehicularMobilityInformation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NdVehicularMobilityInformation&);

  public:
    Ipv6NdVehicularMobilityInformation();
    Ipv6NdVehicularMobilityInformation(const Ipv6NdVehicularMobilityInformation& other);
    virtual ~Ipv6NdVehicularMobilityInformation();
    Ipv6NdVehicularMobilityInformation& operator=(const Ipv6NdVehicularMobilityInformation& other);
    virtual Ipv6NdVehicularMobilityInformation *dup() const override {return new Ipv6NdVehicularMobilityInformation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getLength() const;
    virtual void setLength(unsigned short length);
    virtual unsigned int getType() const;
    virtual void setType(unsigned int type);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NdVehicularMobilityInformation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NdVehicularMobilityInformation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:141</tt> by nedtool.
 * <pre>
 * // MIPv6 New Advertisement Interval Option
 * // RFC 3775 Section 7.3
 * //
 * class Mipv6NdAdvertisementInterval extends cObject
 * {
 *     unsigned int advertisementInterval;    // milliseconds
 * }
 * </pre>
 */
class INET_API Mipv6NdAdvertisementInterval : public ::omnetpp::cObject
{
  protected:
    unsigned int advertisementInterval = 0;

  private:
    void copy(const Mipv6NdAdvertisementInterval& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Mipv6NdAdvertisementInterval&);

  public:
    Mipv6NdAdvertisementInterval();
    Mipv6NdAdvertisementInterval(const Mipv6NdAdvertisementInterval& other);
    virtual ~Mipv6NdAdvertisementInterval();
    Mipv6NdAdvertisementInterval& operator=(const Mipv6NdAdvertisementInterval& other);
    virtual Mipv6NdAdvertisementInterval *dup() const override {return new Mipv6NdAdvertisementInterval(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getAdvertisementInterval() const;
    virtual void setAdvertisementInterval(unsigned int advertisementInterval);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Mipv6NdAdvertisementInterval& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Mipv6NdAdvertisementInterval& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:148</tt> by nedtool.
 * <pre>
 * //MIPv6 Home Agent Information Option
 * //RFC 3775 Section 7.4
 * class Mipv6HaInformation extends cObject
 * {
 *     unsigned int homeAgentPreference;
 *     unsigned int homeAgentLifetime;    // seconds
 * }
 * </pre>
 */
class INET_API Mipv6HaInformation : public ::omnetpp::cObject
{
  protected:
    unsigned int homeAgentPreference = 0;
    unsigned int homeAgentLifetime = 0;

  private:
    void copy(const Mipv6HaInformation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Mipv6HaInformation&);

  public:
    Mipv6HaInformation();
    Mipv6HaInformation(const Mipv6HaInformation& other);
    virtual ~Mipv6HaInformation();
    Mipv6HaInformation& operator=(const Mipv6HaInformation& other);
    virtual Mipv6HaInformation *dup() const override {return new Mipv6HaInformation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getHomeAgentPreference() const;
    virtual void setHomeAgentPreference(unsigned int homeAgentPreference);
    virtual unsigned int getHomeAgentLifetime() const;
    virtual void setHomeAgentLifetime(unsigned int homeAgentLifetime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Mipv6HaInformation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Mipv6HaInformation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:165</tt> by nedtool.
 * <pre>
 * //
 * // Neighbour Discovery for Ipv6.
 * // RFC 2461
 * //
 * // ICMP fields inherited from ~Icmpv6Header:
 * //    - Type
 * //
 * // ICMP fields not implemented:
 * //    - Checksum
 * //    - Reserved
 * //
 * class Ipv6NdMessage extends Icmpv6Header
 * {
 *     //customize(true);
 *     int code = 0;
 * }
 * </pre>
 */
class INET_API Ipv6NdMessage : public ::inet::Icmpv6Header
{
  protected:
    int code = 0;

  private:
    void copy(const Ipv6NdMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NdMessage&);

  public:
    Ipv6NdMessage();
    Ipv6NdMessage(const Ipv6NdMessage& other);
    virtual ~Ipv6NdMessage();
    Ipv6NdMessage& operator=(const Ipv6NdMessage& other);
    virtual Ipv6NdMessage *dup() const override {return new Ipv6NdMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getCode() const;
    virtual void setCode(int code);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NdMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NdMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:175</tt> by nedtool.
 * <pre>
 * //
 * // Router Solicitation Message Format
 * // RFC 4861 Section 4.1
 * //
 * class Ipv6RouterSolicitation extends Ipv6NdMessage
 * {
 *     type = ICMPv6_ROUTER_SOL;
 *     //Possible Options   //FIXME these fields are TLV options!
 * 
 *     // The link-layer address of the sender, if known.
 *     // MUST NOT be included if the Source Address is the unspecified address.
 *     // Otherwise, it SHOULD be included on link layers that have addresses.
 *     MacAddress sourceLinkLayerAddress;
 * 
 * 
 * }
 * </pre>
 */
class INET_API Ipv6RouterSolicitation : public ::inet::Ipv6NdMessage
{
  protected:
    MacAddress sourceLinkLayerAddress;

  private:
    void copy(const Ipv6RouterSolicitation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6RouterSolicitation&);

  public:
    Ipv6RouterSolicitation();
    Ipv6RouterSolicitation(const Ipv6RouterSolicitation& other);
    virtual ~Ipv6RouterSolicitation();
    Ipv6RouterSolicitation& operator=(const Ipv6RouterSolicitation& other);
    virtual Ipv6RouterSolicitation *dup() const override {return new Ipv6RouterSolicitation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const MacAddress& getSourceLinkLayerAddress() const;
    virtual MacAddress& getSourceLinkLayerAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ipv6RouterSolicitation*>(this)->getSourceLinkLayerAddress());}
    virtual void setSourceLinkLayerAddress(const MacAddress& sourceLinkLayerAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6RouterSolicitation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6RouterSolicitation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:193</tt> by nedtool.
 * <pre>
 * //
 * // Router Advertisement Message Format
 * // RFC 2461 Section 4.2
 * // RFC 3775 Section 7.1, RFC 5175 Section 3. (homeAgentFlag)
 * //
 * class Ipv6RouterAdvertisement extends Ipv6NdMessage
 * {
 *     type = ICMPv6_ROUTER_AD;
 *     //Additional ICMP fields
 *     unsigned short curHopLimit;
 *     bool managedAddrConfFlag;    //M-bit
 *     bool otherStatefulConfFlag;    //O-bit
 *     bool homeAgentFlag = false;        //H-bit
 *     unsigned short routerLifetime;  // 0 indicates router is not a default router
 *     unsigned int reachableTime;
 *     unsigned int retransTimer;
 * 
 *     //Possible Options   //FIXME these fields are TLV options!
 * 
 *     MacAddress sourceLinkLayerAddress;        //source link layer option
 *     unsigned int MTU;                //MTU option
 *     Ipv6NdPrefixInformation prefixInformation[];    //Prefix Information Option
 *     Mipv6NdAdvertisementInterval advInterval;    //New Advertisement Interval Option (MIPv6)
 *     Mipv6HaInformation haInformation;    //New Home Agent Information Option (MIPv6)
 * 
 *     //XIANG ZHONG
 *     Ipv6Address srcGlobalAddress;
 *     bool isDadRequired = true;
 * 
 * }
 * </pre>
 */
class INET_API Ipv6RouterAdvertisement : public ::inet::Ipv6NdMessage
{
  protected:
    unsigned short curHopLimit = 0;
    bool managedAddrConfFlag = false;
    bool otherStatefulConfFlag = false;
    bool homeAgentFlag = false;
    unsigned short routerLifetime = 0;
    unsigned int reachableTime = 0;
    unsigned int retransTimer = 0;
    MacAddress sourceLinkLayerAddress;
    unsigned int MTU = 0;
    Ipv6NdPrefixInformation *prefixInformation = nullptr;
    size_t prefixInformation_arraysize = 0;
    Mipv6NdAdvertisementInterval advInterval;
    Mipv6HaInformation haInformation;
    Ipv6Address srcGlobalAddress;
    bool isDadRequired_ = true;

  private:
    void copy(const Ipv6RouterAdvertisement& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6RouterAdvertisement&);

  public:
    Ipv6RouterAdvertisement();
    Ipv6RouterAdvertisement(const Ipv6RouterAdvertisement& other);
    virtual ~Ipv6RouterAdvertisement();
    Ipv6RouterAdvertisement& operator=(const Ipv6RouterAdvertisement& other);
    virtual Ipv6RouterAdvertisement *dup() const override {return new Ipv6RouterAdvertisement(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getCurHopLimit() const;
    virtual void setCurHopLimit(unsigned short curHopLimit);
    virtual bool getManagedAddrConfFlag() const;
    virtual void setManagedAddrConfFlag(bool managedAddrConfFlag);
    virtual bool getOtherStatefulConfFlag() const;
    virtual void setOtherStatefulConfFlag(bool otherStatefulConfFlag);
    virtual bool getHomeAgentFlag() const;
    virtual void setHomeAgentFlag(bool homeAgentFlag);
    virtual unsigned short getRouterLifetime() const;
    virtual void setRouterLifetime(unsigned short routerLifetime);
    virtual unsigned int getReachableTime() const;
    virtual void setReachableTime(unsigned int reachableTime);
    virtual unsigned int getRetransTimer() const;
    virtual void setRetransTimer(unsigned int retransTimer);
    virtual const MacAddress& getSourceLinkLayerAddress() const;
    virtual MacAddress& getSourceLinkLayerAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ipv6RouterAdvertisement*>(this)->getSourceLinkLayerAddress());}
    virtual void setSourceLinkLayerAddress(const MacAddress& sourceLinkLayerAddress);
    virtual unsigned int getMTU() const;
    virtual void setMTU(unsigned int MTU);
    virtual void setPrefixInformationArraySize(size_t size);
    virtual size_t getPrefixInformationArraySize() const;
    virtual const Ipv6NdPrefixInformation& getPrefixInformation(size_t k) const;
    virtual Ipv6NdPrefixInformation& getPrefixInformationForUpdate(size_t k) { handleChange();return const_cast<Ipv6NdPrefixInformation&>(const_cast<Ipv6RouterAdvertisement*>(this)->getPrefixInformation(k));}
    virtual void setPrefixInformation(size_t k, const Ipv6NdPrefixInformation& prefixInformation);
    virtual void insertPrefixInformation(const Ipv6NdPrefixInformation& prefixInformation);
    virtual void insertPrefixInformation(size_t k, const Ipv6NdPrefixInformation& prefixInformation);
    virtual void erasePrefixInformation(size_t k);
    virtual const Mipv6NdAdvertisementInterval& getAdvInterval() const;
    virtual Mipv6NdAdvertisementInterval& getAdvIntervalForUpdate() { handleChange();return const_cast<Mipv6NdAdvertisementInterval&>(const_cast<Ipv6RouterAdvertisement*>(this)->getAdvInterval());}
    virtual void setAdvInterval(const Mipv6NdAdvertisementInterval& advInterval);
    virtual const Mipv6HaInformation& getHaInformation() const;
    virtual Mipv6HaInformation& getHaInformationForUpdate() { handleChange();return const_cast<Mipv6HaInformation&>(const_cast<Ipv6RouterAdvertisement*>(this)->getHaInformation());}
    virtual void setHaInformation(const Mipv6HaInformation& haInformation);
    virtual const Ipv6Address& getSrcGlobalAddress() const;
    virtual Ipv6Address& getSrcGlobalAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6RouterAdvertisement*>(this)->getSrcGlobalAddress());}
    virtual void setSrcGlobalAddress(const Ipv6Address& srcGlobalAddress);
    virtual bool isDadRequired() const;
    virtual void setIsDadRequired(bool isDadRequired);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6RouterAdvertisement& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6RouterAdvertisement& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:223</tt> by nedtool.
 * <pre>
 * //
 * // Neighbour Solicitation Message Format
 * // RFC 4861 Section 4.3
 * //
 * class Ipv6NeighbourSolicitation extends Ipv6NdMessage
 * {
 *     type = ICMPv6_NEIGHBOUR_SOL;
 *     //Additional ICMP fields
 *     Ipv6Address targetAddress;// MUST NOT be a multicast address.
 * 
 * 
 *     //Possible Options   //FIXME these fields are TLV options!
 * 
 *     // The link-layer address for the sender.
 *     // MUST NOT be included when the source IP address is the unspecified address.
 *     // Otherwise, on link layers that have addresses this option MUST be included in multicast
 *     // solicitations and SHOULD be included in unicast solicitations.
 *     MacAddress sourceLinkLayerAddress;
 *     Ipv6NdAddressRegistrationOption ARO;
 * 
 *     //XIANG ZHONG
 *     bool isDadMsg = false;
 *     bool isRelay = false;
 *     Ipv6Address relayAddress;
 *     Ipv6Address linkLocalAddress;
 *     int hopDistance = 0;
 * 
 * }
 * </pre>
 */
class INET_API Ipv6NeighbourSolicitation : public ::inet::Ipv6NdMessage
{
  protected:
    Ipv6Address targetAddress;
    MacAddress sourceLinkLayerAddress;
    Ipv6NdAddressRegistrationOption ARO;
    bool isDadMsg_ = false;
    bool isRelay_ = false;
    Ipv6Address relayAddress;
    Ipv6Address linkLocalAddress;
    int hopDistance = 0;

  private:
    void copy(const Ipv6NeighbourSolicitation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NeighbourSolicitation&);

  public:
    Ipv6NeighbourSolicitation();
    Ipv6NeighbourSolicitation(const Ipv6NeighbourSolicitation& other);
    virtual ~Ipv6NeighbourSolicitation();
    Ipv6NeighbourSolicitation& operator=(const Ipv6NeighbourSolicitation& other);
    virtual Ipv6NeighbourSolicitation *dup() const override {return new Ipv6NeighbourSolicitation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv6Address& getTargetAddress() const;
    virtual Ipv6Address& getTargetAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6NeighbourSolicitation*>(this)->getTargetAddress());}
    virtual void setTargetAddress(const Ipv6Address& targetAddress);
    virtual const MacAddress& getSourceLinkLayerAddress() const;
    virtual MacAddress& getSourceLinkLayerAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ipv6NeighbourSolicitation*>(this)->getSourceLinkLayerAddress());}
    virtual void setSourceLinkLayerAddress(const MacAddress& sourceLinkLayerAddress);
    virtual const Ipv6NdAddressRegistrationOption& getARO() const;
    virtual Ipv6NdAddressRegistrationOption& getAROForUpdate() { handleChange();return const_cast<Ipv6NdAddressRegistrationOption&>(const_cast<Ipv6NeighbourSolicitation*>(this)->getARO());}
    virtual void setARO(const Ipv6NdAddressRegistrationOption& ARO);
    virtual bool isDadMsg() const;
    virtual void setIsDadMsg(bool isDadMsg);
    virtual bool isRelay() const;
    virtual void setIsRelay(bool isRelay);
    virtual const Ipv6Address& getRelayAddress() const;
    virtual Ipv6Address& getRelayAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6NeighbourSolicitation*>(this)->getRelayAddress());}
    virtual void setRelayAddress(const Ipv6Address& relayAddress);
    virtual const Ipv6Address& getLinkLocalAddress() const;
    virtual Ipv6Address& getLinkLocalAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6NeighbourSolicitation*>(this)->getLinkLocalAddress());}
    virtual void setLinkLocalAddress(const Ipv6Address& linkLocalAddress);
    virtual int getHopDistance() const;
    virtual void setHopDistance(int hopDistance);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NeighbourSolicitation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NeighbourSolicitation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:252</tt> by nedtool.
 * <pre>
 * //
 * // Neighbour Advertisement Message Format
 * // RFC 2461 Section 4.4
 * //
 * class Ipv6NeighbourAdvertisement extends Ipv6NdMessage
 * {
 *     type = ICMPv6_NEIGHBOUR_AD;
 *     //Additional ICMP fields
 *     bool routerFlag;    //R-flag
 *     bool solicitedFlag;    //S-flag
 *     bool overrideFlag;    //O-flag
 *     Ipv6Address targetAddress;// MUST NOT be a multicast address.
 * 
 *     //Possible Options   //FIXME these fields are TLV options!
 * 
 * 	//XIANG ZHONG
 *     MacAddress targetLinkLayerAddress;    //Target Link Layer Address option
 *     MacAddress sourceLinkLayerAddress;
 *     Ipv6NdAddressRegistrationOption ARO;
 *     Ipv6NdPrefixInformation prefixInformation[];    //Prefix Information Option
 *     Ipv6Address routerAddress;
 * }
 * </pre>
 */
class INET_API Ipv6NeighbourAdvertisement : public ::inet::Ipv6NdMessage
{
  protected:
    bool routerFlag = false;
    bool solicitedFlag = false;
    bool overrideFlag = false;
    Ipv6Address targetAddress;
    MacAddress targetLinkLayerAddress;
    MacAddress sourceLinkLayerAddress;
    Ipv6NdAddressRegistrationOption ARO;
    Ipv6NdPrefixInformation *prefixInformation = nullptr;
    size_t prefixInformation_arraysize = 0;
    Ipv6Address routerAddress;

  private:
    void copy(const Ipv6NeighbourAdvertisement& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NeighbourAdvertisement&);

  public:
    Ipv6NeighbourAdvertisement();
    Ipv6NeighbourAdvertisement(const Ipv6NeighbourAdvertisement& other);
    virtual ~Ipv6NeighbourAdvertisement();
    Ipv6NeighbourAdvertisement& operator=(const Ipv6NeighbourAdvertisement& other);
    virtual Ipv6NeighbourAdvertisement *dup() const override {return new Ipv6NeighbourAdvertisement(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getRouterFlag() const;
    virtual void setRouterFlag(bool routerFlag);
    virtual bool getSolicitedFlag() const;
    virtual void setSolicitedFlag(bool solicitedFlag);
    virtual bool getOverrideFlag() const;
    virtual void setOverrideFlag(bool overrideFlag);
    virtual const Ipv6Address& getTargetAddress() const;
    virtual Ipv6Address& getTargetAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6NeighbourAdvertisement*>(this)->getTargetAddress());}
    virtual void setTargetAddress(const Ipv6Address& targetAddress);
    virtual const MacAddress& getTargetLinkLayerAddress() const;
    virtual MacAddress& getTargetLinkLayerAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ipv6NeighbourAdvertisement*>(this)->getTargetLinkLayerAddress());}
    virtual void setTargetLinkLayerAddress(const MacAddress& targetLinkLayerAddress);
    virtual const MacAddress& getSourceLinkLayerAddress() const;
    virtual MacAddress& getSourceLinkLayerAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ipv6NeighbourAdvertisement*>(this)->getSourceLinkLayerAddress());}
    virtual void setSourceLinkLayerAddress(const MacAddress& sourceLinkLayerAddress);
    virtual const Ipv6NdAddressRegistrationOption& getARO() const;
    virtual Ipv6NdAddressRegistrationOption& getAROForUpdate() { handleChange();return const_cast<Ipv6NdAddressRegistrationOption&>(const_cast<Ipv6NeighbourAdvertisement*>(this)->getARO());}
    virtual void setARO(const Ipv6NdAddressRegistrationOption& ARO);
    virtual void setPrefixInformationArraySize(size_t size);
    virtual size_t getPrefixInformationArraySize() const;
    virtual const Ipv6NdPrefixInformation& getPrefixInformation(size_t k) const;
    virtual Ipv6NdPrefixInformation& getPrefixInformationForUpdate(size_t k) { handleChange();return const_cast<Ipv6NdPrefixInformation&>(const_cast<Ipv6NeighbourAdvertisement*>(this)->getPrefixInformation(k));}
    virtual void setPrefixInformation(size_t k, const Ipv6NdPrefixInformation& prefixInformation);
    virtual void insertPrefixInformation(const Ipv6NdPrefixInformation& prefixInformation);
    virtual void insertPrefixInformation(size_t k, const Ipv6NdPrefixInformation& prefixInformation);
    virtual void erasePrefixInformation(size_t k);
    virtual const Ipv6Address& getRouterAddress() const;
    virtual Ipv6Address& getRouterAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6NeighbourAdvertisement*>(this)->getRouterAddress());}
    virtual void setRouterAddress(const Ipv6Address& routerAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NeighbourAdvertisement& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NeighbourAdvertisement& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:275</tt> by nedtool.
 * <pre>
 * //
 * // Redirect Message Format
 * // RFC 2461 Section 4.5
 * //
 * class Ipv6Redirect extends Ipv6NdMessage
 * {
 *     type = ICMPv6_REDIRECT;
 *     //Additional ICMP fields
 *     Ipv6Address targetAddress;
 *     Ipv6Address destinationAddress;
 * 
 *     //Possible Options   //FIXME these fields are TLV options!
 * 
 *     MacAddress targetLinkLayerAddress;
 *     //Redirected Header Encapsulated Msg
 * }
 * 
 * 
 * //XIANG ZHONG
 * </pre>
 */
class INET_API Ipv6Redirect : public ::inet::Ipv6NdMessage
{
  protected:
    Ipv6Address targetAddress;
    Ipv6Address destinationAddress;
    MacAddress targetLinkLayerAddress;

  private:
    void copy(const Ipv6Redirect& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6Redirect&);

  public:
    Ipv6Redirect();
    Ipv6Redirect(const Ipv6Redirect& other);
    virtual ~Ipv6Redirect();
    Ipv6Redirect& operator=(const Ipv6Redirect& other);
    virtual Ipv6Redirect *dup() const override {return new Ipv6Redirect(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv6Address& getTargetAddress() const;
    virtual Ipv6Address& getTargetAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6Redirect*>(this)->getTargetAddress());}
    virtual void setTargetAddress(const Ipv6Address& targetAddress);
    virtual const Ipv6Address& getDestinationAddress() const;
    virtual Ipv6Address& getDestinationAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6Redirect*>(this)->getDestinationAddress());}
    virtual void setDestinationAddress(const Ipv6Address& destinationAddress);
    virtual const MacAddress& getTargetLinkLayerAddress() const;
    virtual MacAddress& getTargetLinkLayerAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ipv6Redirect*>(this)->getTargetLinkLayerAddress());}
    virtual void setTargetLinkLayerAddress(const MacAddress& targetLinkLayerAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6Redirect& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6Redirect& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:292</tt> by nedtool.
 * <pre>
 * //Duplicate Address Request
 * class Ipv6DuplicateAddrReq extends Ipv6NdMessage
 * {
 *     Ipv6Address sourceAddress; //Ipv6 source
 *     Ipv6Address destinationAddress; //Ipv6 dest
 *     unsigned short curHopLimit;   //hop limit 
 * 
 *     //ICMP fields
 *     type = ICMPv6_NEIGHBOUR_DAR; //type DAR=157, DAC=158
 *     Ipv6Address registeredAddress; //registered address 
 *     unsigned short registLifetime;  //registration lifetime 
 *     unsigned int status = 0;  //status
 *     //EUI 64    EUI-64 interface identifier uniquely identify the interface of the registered address      
 *     //    uint32 normal;
 *     //    uint32 low;
 *     //    short len;    // in bits, 1..64
 *     InterfaceIdentifier EUI64;
 * 
 * 
 * 
 * }
 * </pre>
 */
class INET_API Ipv6DuplicateAddrReq : public ::inet::Ipv6NdMessage
{
  protected:
    Ipv6Address sourceAddress;
    Ipv6Address destinationAddress;
    unsigned short curHopLimit = 0;
    Ipv6Address registeredAddress;
    unsigned short registLifetime = 0;
    unsigned int status = 0;
    InterfaceIdentifier EUI64;

  private:
    void copy(const Ipv6DuplicateAddrReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6DuplicateAddrReq&);

  public:
    Ipv6DuplicateAddrReq();
    Ipv6DuplicateAddrReq(const Ipv6DuplicateAddrReq& other);
    virtual ~Ipv6DuplicateAddrReq();
    Ipv6DuplicateAddrReq& operator=(const Ipv6DuplicateAddrReq& other);
    virtual Ipv6DuplicateAddrReq *dup() const override {return new Ipv6DuplicateAddrReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv6Address& getSourceAddress() const;
    virtual Ipv6Address& getSourceAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6DuplicateAddrReq*>(this)->getSourceAddress());}
    virtual void setSourceAddress(const Ipv6Address& sourceAddress);
    virtual const Ipv6Address& getDestinationAddress() const;
    virtual Ipv6Address& getDestinationAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6DuplicateAddrReq*>(this)->getDestinationAddress());}
    virtual void setDestinationAddress(const Ipv6Address& destinationAddress);
    virtual unsigned short getCurHopLimit() const;
    virtual void setCurHopLimit(unsigned short curHopLimit);
    virtual const Ipv6Address& getRegisteredAddress() const;
    virtual Ipv6Address& getRegisteredAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6DuplicateAddrReq*>(this)->getRegisteredAddress());}
    virtual void setRegisteredAddress(const Ipv6Address& registeredAddress);
    virtual unsigned short getRegistLifetime() const;
    virtual void setRegistLifetime(unsigned short registLifetime);
    virtual unsigned int getStatus() const;
    virtual void setStatus(unsigned int status);
    virtual const InterfaceIdentifier& getEUI64() const;
    virtual InterfaceIdentifier& getEUI64ForUpdate() { handleChange();return const_cast<InterfaceIdentifier&>(const_cast<Ipv6DuplicateAddrReq*>(this)->getEUI64());}
    virtual void setEUI64(const InterfaceIdentifier& EUI64);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6DuplicateAddrReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6DuplicateAddrReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:316</tt> by nedtool.
 * <pre>
 * //Duplicate Address Confirm
 * class Ipv6DuplicateAddrConfirm extends Ipv6NdMessage
 * {
 *     //IP field 
 *     Ipv6Address sourceAddress; //Ipv6 source
 *     Ipv6Address destinationAddress; //Ipv6 dest
 *     unsigned short curHopLimit;   //hop limit 
 * 
 *     //ICMP fields
 *     type = ICMPv6_NEIGHBOUR_DAC; //type DAR=157, DAC=158
 *     Ipv6Address registeredAddress; //registered address 
 *     unsigned short registLifetime;  //registration lifetime 
 *     InterfaceIdentifier EUI64;  //EUI-64 
 *     unsigned int status = 0;  //status
 * 
 * 
 * }
 * </pre>
 */
class INET_API Ipv6DuplicateAddrConfirm : public ::inet::Ipv6NdMessage
{
  protected:
    Ipv6Address sourceAddress;
    Ipv6Address destinationAddress;
    unsigned short curHopLimit = 0;
    Ipv6Address registeredAddress;
    unsigned short registLifetime = 0;
    InterfaceIdentifier EUI64;
    unsigned int status = 0;

  private:
    void copy(const Ipv6DuplicateAddrConfirm& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6DuplicateAddrConfirm&);

  public:
    Ipv6DuplicateAddrConfirm();
    Ipv6DuplicateAddrConfirm(const Ipv6DuplicateAddrConfirm& other);
    virtual ~Ipv6DuplicateAddrConfirm();
    Ipv6DuplicateAddrConfirm& operator=(const Ipv6DuplicateAddrConfirm& other);
    virtual Ipv6DuplicateAddrConfirm *dup() const override {return new Ipv6DuplicateAddrConfirm(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv6Address& getSourceAddress() const;
    virtual Ipv6Address& getSourceAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6DuplicateAddrConfirm*>(this)->getSourceAddress());}
    virtual void setSourceAddress(const Ipv6Address& sourceAddress);
    virtual const Ipv6Address& getDestinationAddress() const;
    virtual Ipv6Address& getDestinationAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6DuplicateAddrConfirm*>(this)->getDestinationAddress());}
    virtual void setDestinationAddress(const Ipv6Address& destinationAddress);
    virtual unsigned short getCurHopLimit() const;
    virtual void setCurHopLimit(unsigned short curHopLimit);
    virtual const Ipv6Address& getRegisteredAddress() const;
    virtual Ipv6Address& getRegisteredAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6DuplicateAddrConfirm*>(this)->getRegisteredAddress());}
    virtual void setRegisteredAddress(const Ipv6Address& registeredAddress);
    virtual unsigned short getRegistLifetime() const;
    virtual void setRegistLifetime(unsigned short registLifetime);
    virtual const InterfaceIdentifier& getEUI64() const;
    virtual InterfaceIdentifier& getEUI64ForUpdate() { handleChange();return const_cast<InterfaceIdentifier&>(const_cast<Ipv6DuplicateAddrConfirm*>(this)->getEUI64());}
    virtual void setEUI64(const InterfaceIdentifier& EUI64);
    virtual unsigned int getStatus() const;
    virtual void setStatus(unsigned int status);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6DuplicateAddrConfirm& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6DuplicateAddrConfirm& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:335</tt> by nedtool.
 * <pre>
 * class Ipv6NdControlInfo extends cObject
 * {
 *     Ipv6Address nextHop;   // next hop address
 *     int interfaceId = -1; // interface on which the datagram should be sent
 *     bool fromHL = false;    // packet came from higher layer
 * }
 * </pre>
 */
class INET_API Ipv6NdControlInfo : public ::omnetpp::cObject
{
  protected:
    Ipv6Address nextHop;
    int interfaceId = -1;
    bool fromHL = false;

  private:
    void copy(const Ipv6NdControlInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NdControlInfo&);

  public:
    Ipv6NdControlInfo();
    Ipv6NdControlInfo(const Ipv6NdControlInfo& other);
    virtual ~Ipv6NdControlInfo();
    Ipv6NdControlInfo& operator=(const Ipv6NdControlInfo& other);
    virtual Ipv6NdControlInfo *dup() const override {return new Ipv6NdControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv6Address& getNextHop() const;
    virtual Ipv6Address& getNextHopForUpdate() { return const_cast<Ipv6Address&>(const_cast<Ipv6NdControlInfo*>(this)->getNextHop());}
    virtual void setNextHop(const Ipv6Address& nextHop);
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual bool getFromHL() const;
    virtual void setFromHL(bool fromHL);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NdControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NdControlInfo& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_IPV6NDMESSAGE_M_H

